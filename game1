<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Vector Rush - Momentum Platformer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    :root {
      --text: #0b1020;
      --hud-bg: rgba(255,255,255,0.86);
      --hud-text: #0a0a0a;
      --accent: #34d1ff;
      --panel: rgba(255,255,255,0.92);
      --panel-d: rgba(20,20,28,0.92);
      --shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    html, body {
      margin: 0; padding: 0; height: 100%;
      background-color: #0b1020;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      color-scheme: light dark;
    }
    #game-container { position: relative; width: 100%; height: 100%; }
    #game-canvas { position: absolute; inset: 0; width: 100%; height: 100%; display: block; touch-action: none; }
    #ui-layer { position: absolute; inset: 0; pointer-events: none; color: var(--hud-text); }
    #hud {
      position: absolute; top: env(safe-area-inset-top, 0); left: env(safe-area-inset-left, 0); right: env(safe-area-inset-right, 0);
      display: flex; align-items: center; gap: 10px; padding: 10px 14px; mix-blend-mode: normal;
    }
    .hud-card {
      pointer-events: auto; display: inline-flex; align-items: center; gap: 8px;
      padding: 8px 12px; border-radius: 12px; background: var(--hud-bg); box-shadow: var(--shadow);
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); font-weight: 600; user-select: none;
    }
    .ring-icon {
      width: 16px; height: 16px; border-radius: 50%;
      box-shadow: inset 0 0 0 4px #ffcc33, 0 2px 4px rgba(0,0,0,0.25);
      background: radial-gradient(circle at 30% 30%, #fff9cc, #ffd84d 45%, #d59a00 70%, #b78000 100%);
    }
    .btn {
      appearance: none; border: 0; background: #121620; color: #fff; border-radius: 10px;
      padding: 8px 14px; font-weight: 700; cursor: pointer; transition: transform .1s ease, background .2s ease;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    .btn:hover { background: #2a3141; }
    .btn:active { transform: scale(0.96); }
    .btn.primary { background: var(--accent); color: #0b1020; }
    .btn.primary:hover { background: #58d9ff; }
    #controls {
      position: absolute; left: env(safe-area-inset-left, 0); right: env(safe-area-inset-right, 0);
      bottom: env(safe-area-inset-bottom, 0); padding: 10px;
      display: none; grid-template-columns: 1fr 1fr; gap: 10px;
    }
    .control-cluster { display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(2, 64px); gap: 10px; }
    .control-pad {
      pointer-events: auto; width: 100%; height: 100%; border-radius: 16px; background: rgba(255,255,255,0.4);
      box-shadow: var(--shadow); display: flex; align-items: center; justify-content: center;
      font-weight: 900; color: #0b1020; user-select: none; touch-action: none;
      backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px);
    }
    .control-pad.round { border-radius: 50%; }
    .control-pad:active { transform: scale(0.98); background: rgba(255,255,255,0.6); }
    .screen {
      position: absolute; inset: 0; display: flex; align-items: center; justify-content: center;
      padding: 24px; background: rgba(0,0,0,0.35); backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px);
      z-index: 5; pointer-events: auto; opacity: 0; transition: opacity 0.3s ease;
    }
    .screen.visible { opacity: 1; }
    .screen:not(.visible) { pointer-events: none; }
    .panel {
      max-width: min(720px, 96vw); width: 100%; border-radius: 16px; padding: 24px;
      background: var(--panel); color: #0b1020; box-shadow: var(--shadow);
      display: flex; flex-direction: column; gap: 16px;
    }
    .panel h1, .panel h2 { margin: 0; font-size: 32px; text-align: center; }
    .panel p { margin: 0; line-height: 1.6; opacity: 0.9; }
    #level-select-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 16px; }
    .level-card {
      background: rgba(0,0,0,0.05); padding: 16px; border-radius: 12px; text-align: center; cursor: pointer;
      transition: transform .2s ease, box-shadow .2s ease;
    }
    .level-card:hover { transform: translateY(-4px); box-shadow: 0 8px 20px rgba(0,0,0,0.15); }
    .level-card h3 { margin: 0 0 8px; }
    .level-card .best-time { font-size: 12px; opacity: 0.7; }
    #dashbar {
      position: relative; width: 120px; height: 10px; border-radius: 999px;
      background: rgba(0,0,0,0.12); overflow: hidden;
    }
    #dashbar .fill {
      position: absolute; left: 0; top: 0; bottom: 0; width: 0%; border-radius: 999px;
      background: linear-gradient(90deg, #00d4ff, #34ff8a);
      box-shadow: 0 0 10px rgba(0, 210, 255, 0.5); transition: width 0.1s linear;
    }
    @media (prefers-color-scheme: dark) {
      .panel { background: var(--panel-d); color: #e9eef7; }
      .hud-card { background: rgba(20,22,30,0.75); color: #e8ecf5; }
      .control-pad { background: rgba(18,22,32,0.55); color: #e8ecf5; }
      .control-pad:active { background: rgba(18,22,32,0.75); }
      .level-card { background: rgba(255,255,255,0.08); }
    }
    @media (max-width: 820px) { #controls { display: grid; } }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game-canvas" aria-label="Vector Rush Game Canvas"></canvas>
    <div id="ui-layer">
      <!-- HUD -->
      <div id="hud" style="display: none;">
        <div class="hud-card" title="Rings">
          <div class="ring-icon" aria-hidden="true"></div>
          <div id="ring-count">0</div>
          <div style="width:1px;height:18px;background:rgba(0,0,0,0.15);margin:0 4px;"></div>
          <div id="timer">0:00.0</div>
        </div>
        <div class="hud-card" title="Dash Ready">
          <span style="font-weight:700;opacity:.8">Dash</span>
          <div id="dashbar"><div class="fill"></div></div>
        </div>
        <div style="margin-left:auto;" class="hud-card">
          <button class="btn" id="btn-pause" title="Pause (P or Esc)">Pause</button>
          <button class="btn" id="btn-restart" title="Retry from Checkpoint (R)">Retry</button>
        </div>
      </div>

      <!-- On-screen Controls -->
      <div id="controls" aria-label="On-screen controls">
        <div class="control-cluster">
          <div class="control-pad" data-act="left" style="grid-column:1;grid-row:1/span 2;"><canvas width="32" height="32" data-icon="arrow-left"></canvas></div>
          <div class="control-pad" data-act="right" style="grid-column:3;grid-row:1/span 2;"><canvas width="32" height="32" data-icon="arrow-right"></canvas></div>
          <div class="control-pad" data-act="down" style="grid-column:2;grid-row:2;"><canvas width="32" height="32" data-icon="arrow-down"></canvas></div>
        </div>
        <div class="control-cluster">
          <div class="control-pad round" data-act="jump" style="grid-column:2;grid-row:1;"><canvas width="32" height="32" data-icon="jump"></canvas></div>
          <div class="control-pad round" data-act="dash" style="grid-column:1;grid-row:2;"><canvas width="32" height="32" data-icon="dash"></canvas></div>
        </div>
      </div>

      <!-- UI Screens -->
      <div id="title-screen" class="screen visible">
        <div class="panel" style="text-align: center;">
          <h1 style="font-size: 48px; margin-bottom: 0;">Vector Rush</h1>
          <p style="font-size: 20px; margin-top: 0; color: var(--accent);">A Momentum Platformer</p>
          <p>Race through challenging stages, master the controls, and achieve the best time.</p>
          <p><b>Controls:</b></p>
          <p>
            <b>Move:</b> Arrow Keys / WASD<br>
            <b>Jump:</b> Space / Up Arrow<br>
            <b>Dash:</b> X / Shift<br>
            <b>Pause:</b> P / Esc<br>
            <b>Retry:</b> R
          </p>
          <div style="display:flex;gap:12px;justify-content:center; margin-top: 20px;">
            <button class="btn primary" id="btn-play">Play Game</button>
          </div>
        </div>
      </div>

      <div id="level-select-screen" class="screen">
        <div class="panel">
          <h2>Select a Stage</h2>
          <div id="level-select-grid"></div>
        </div>
      </div>

      <div id="pause-screen" class="screen">
        <div class="panel">
          <h2 style="font-size:28px;">Paused</h2>
           <p>Desktop: P/Esc to Resume. Mobile: Tap Resume.</p>
          <div style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap;">
            <button class="btn primary" id="btn-resume">Resume</button>
            <button class="btn" id="btn-level-select">Back to Level Select</button>
            <button class="btn" id="btn-reset-level">Restart Level</button>
          </div>
        </div>
      </div>

      <div id="level-complete-screen" class="screen">
        <div class="panel">
          <h2 style="font-size:28px;">Level Complete!</h2>
          <div id="level-results" style="text-align:center;font-size:18px;font-weight:600;"></div>
          <div style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap;">
            <button class="btn primary" id="btn-next-level">Next Level</button>
            <button class="btn" id="btn-level-select-2">Level Select</button>
            <button class="btn" id="btn-retry-level">Retry Level</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    "use strict";

    // --- UTILITIES ---
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const lerp = (a, b, t) => a + (b - a) * t;
    const RNG = (() => { let s=1; return { setSeed(d){s=d}, next(){s^=s<<13;s^=s>>>17;s^=s<<5;return(s>>>0)/4294967296}, range(a,b){return a+(b-a)*this.next()} }; })();

    // --- GAME CONSTANTS ---
    const CFG = {
        GRAVITY: 2200, MAX_SPEED: 480, MAX_AIR_SPEED: 550, MAX_DASH_SPEED: 950,
        ACCEL_GROUND: 3000, ACCEL_AIR: 2200, DECEL_GROUND: 2500, DECEL_ROLL: 1000,
        JUMP_VELOCITY: 820, WALL_SLIDE_SPEED: 300, WALL_JUMP_VELOCITY: { x: 550, y: 800 },
        DASH_BOOST: 600, DASH_COOLDOWN: 1.0, ROLL_SPEED_MIN: 200,
        COYOTE_TIME: 0.1, JUMP_BUFFER_TIME: 0.1,
        INVINCIBLE_TIME: 1.5, RESPAWN_TIME: 0.5,
    };

    // --- GAME STATES ---
    const GAME_STATE = {
        TITLE: 0, LEVEL_SELECT: 1, PLAYING: 2, PAUSED: 3, LEVEL_COMPLETE: 4
    };

    // --- ENTITY TYPES ---
    const ENTITY_TYPE = {
        PLATFORM: 1, MOVING_PLATFORM: 2, SPIKE: 3, SPRING: 4, BOOSTER: 5,
        RING: 6, ENEMY_WASP: 7, ENEMY_PATROL: 8, CHECKPOINT: 9, GOAL: 10
    };
    
    // --- AUDIO SYSTEM ---
    const Sfx = (() => {
        let ctx, BGM, musicPlaying = false;
        const now = () => (ctx ? ctx.currentTime : 0);
        function ensure() { 
            if (!ctx) {
                try {
                    ctx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive', sampleRate: 44100 }); 
                } catch(e) {
                    console.warn("Audio not available");
                }
            }
            return ctx; 
        }
        const play = (buffer, playbackRate = 1, vol = 0.5) => {
            if (!ctx) return;
            try {
                const s = ctx.createBufferSource(); s.buffer = buffer; s.playbackRate.value = playbackRate;
                const g = ctx.createGain(); g.gain.value = vol; s.connect(g).connect(ctx.destination); s.start();
            } catch(e) {}
        };
        const synth = (params) => {
            const c = ensure(); 
            if (!c) return null;
            const dur = params.dur ?? 0.1; const len = Math.ceil(dur * c.sampleRate);
            const buff = c.createBuffer(1, len, c.sampleRate); const data = buff.getChannelData(0);
            const attack = params.attack ?? 0.01; const decay = params.decay ?? 0.1;
            for (let i = 0; i < len; i++) {
                const t = i / c.sampleRate;
                const env = t < attack ? t/attack : Math.exp(-(t-attack)/decay);
                let s = 0;
                if (params.type === 'noise') s = Math.random() * 2 - 1;
                else {
                    const f = params.freq * (1 - (params.slide??0) * t);
                    if(params.type === 'sine') s = Math.sin(f * t * Math.PI * 2);
                    if(params.type === 'square') s = Math.sign(Math.sin(f * t * Math.PI * 2));
                    if(params.type === 'saw') s = (f*t) % 1 * 2 - 1;
                    if(params.type === 'tri') s = Math.abs((f*t) % 1 * 4 - 2) - 1;
                }
                data[i] = s * env * (params.vol ?? 0.5);
            }
            return buff;
        };
        const sounds = {};
        const initSounds = () => {
            sounds.jump = synth({ type: 'sine', freq: 440, dur: 0.1, decay: 0.1, attack: 0.005 });
            sounds.land = synth({ type: 'noise', freq: 100, dur: 0.1, decay: 0.05 });
            sounds.dash = synth({ type: 'saw', freq: 520, slide: 0.5, dur: 0.2, decay: 0.15, vol: 0.4 });
            sounds.ring = synth({ type: 'tri', freq: 1320, dur: 0.08, decay: 0.1 });
            sounds.hurt = synth({ type: 'noise', freq: 200, dur: 0.3, decay: 0.2, vol: 0.7 });
            sounds.spring = synth({ type: 'sine', freq: 760, dur: 0.25, decay: 0.2, attack: 0.02 });
            sounds.checkpoint = synth({ type: 'saw', freq: 700, dur: 0.15, decay: 0.15, vol: 0.4 });
            sounds.enemy_hit = synth({ type: 'square', freq: 280, dur: 0.15, decay: 0.1 });
            sounds.goal = synth({ type: 'tri', freq: 660, dur: 0.4, decay: 0.35, attack: 0.01 });
            sounds.ui_click = synth({ type: 'tri', freq: 660, dur: 0.08, decay: 0.08 });
        };
        
        return {
            init() { 
                window.addEventListener('pointerdown', () => { ensure(); initSounds(); }, {once:true}); 
                window.addEventListener('keydown', () => { ensure(); initSounds(); }, {once:true}); 
            },
            play: (name, rate = 1, vol) => { if (sounds[name]) play(sounds[name], rate, vol); },
            startMusic() {},
            stopMusic() {},
            resumeContext() { if(ctx && ctx.state === "suspended") ctx.resume(); }
        };
    })();

    const Input = {
        left: false, right: false, up: false, down: false, dash: false, jump: false,
        _pressed: new Set(),
        init() {
            window.addEventListener("keydown", e => this.map(e.key, true));
            window.addEventListener("keyup", e => this.map(e.key, false));
            // Touch controls
            document.querySelectorAll("[data-act]").forEach(el => {
                const act = el.dataset.act;
                const handler = (v) => {
                    if (act === 'jump') this.up = v;
                    else this[act] = v;
                    if (v) this._pressed.add(act);
                    Sfx.resumeContext();
                };
                el.addEventListener("touchstart", e => { e.preventDefault(); handler(true) }, {passive:false});
                el.addEventListener("touchend", e => { e.preventDefault(); handler(false) }, {passive:false});
                el.addEventListener("touchcancel", e => { e.preventDefault(); handler(false) }, {passive:false});
                el.addEventListener("pointerdown", e => { e.preventDefault(); handler(true) }, {passive:false});
                el.addEventListener("pointerup", e => { e.preventDefault(); handler(false) }, {passive:false});
                el.addEventListener("pointercancel", e => { e.preventDefault(); handler(false) }, {passive:false});
            });
        },
        map(k, v) {
            k = k.toLowerCase();
            if (["arrowleft","a"].includes(k)) this.left = v;
            if (["arrowright","d"].includes(k)) this.right = v;
            if (["arrowup","w"," "].includes(k)) { this.up = v; if (v) this._pressed.add('up'); }
            if (["arrowdown","s"].includes(k)) this.down = v;
            if (["x","c","shift"].includes(k)) { this.dash = v; if (v) this._pressed.add('dash'); }
            if (["p","escape"].includes(k) && v) { Game.togglePause(); this._pressed.add('pause'); }
            if (k === 'r' && v) { if(Game.player) Game.player.respawn(); this._pressed.add('restart'); }
            if(v) this._pressed.add(k);
        },
        isPressed(key) { return this._pressed.has(key); },
        clearPressed() { this._pressed.clear(); }
    };

    const UI = {
        init() {
            // Screen transitions
            document.getElementById('btn-play').addEventListener('click', () => { Game.setState(GAME_STATE.LEVEL_SELECT); Sfx.play('ui_click'); });
            [document.getElementById('btn-level-select'), document.getElementById('btn-level-select-2')].forEach(b => b.addEventListener('click', () => { Game.setState(GAME_STATE.LEVEL_SELECT); Sfx.play('ui_click'); }));
            // Pause controls
            document.getElementById('btn-pause').addEventListener('click', () => Game.setState(GAME_STATE.PAUSED));
            document.getElementById('btn-resume').addEventListener('click', () => Game.setState(GAME_STATE.PLAYING));
            // Restart/Retry
            document.getElementById('btn-restart').addEventListener('click', () => { if(Game.player) Game.player.respawn(); });
            document.getElementById('btn-reset-level').addEventListener('click', () => { Game.loadLevel(Game.currentLevelIndex); Sfx.play('ui_click'); });
            document.getElementById('btn-retry-level').addEventListener('click', () => { Game.loadLevel(Game.currentLevelIndex); Sfx.play('ui_click'); });
            // Level complete
            document.getElementById('btn-next-level').addEventListener('click', () => { Game.loadLevel(Game.currentLevelIndex + 1); Sfx.play('ui_click'); });
            
            this.buildLevelSelect();
            this.drawControlIcons();
        },
        show(id) { document.getElementById(id).classList.add('visible'); },
        hide(id) { document.getElementById(id).classList.remove('visible'); },
        update(state) {
            ['title-screen', 'level-select-screen', 'pause-screen', 'level-complete-screen'].forEach(s => this.hide(s));
            document.getElementById('hud').style.display = 'none';
            switch(state) {
                case GAME_STATE.TITLE: this.show('title-screen'); break;
                case GAME_STATE.LEVEL_SELECT: this.show('level-select-screen'); break;
                case GAME_STATE.PLAYING: document.getElementById('hud').style.display = 'flex'; break;
                case GAME_STATE.PAUSED: this.show('pause-screen'); document.getElementById('hud').style.display = 'flex'; break;
                case GAME_STATE.LEVEL_COMPLETE: this.show('level-complete-screen'); document.getElementById('hud').style.display = 'flex'; break;
            }
        },
        updateHUD(player, time) {
            if (!player) return;
            document.getElementById('ring-count').textContent = player.ringCount;
            document.getElementById('timer').textContent = this.formatTime(time);
            const dashFill = clamp(1 - (player.dashCD / CFG.DASH_COOLDOWN), 0, 1) * 100;
            document.querySelector("#dashbar .fill").style.width = `${dashFill}%`;
        },
        showLevelComplete(time, rings) {
            document.getElementById('level-results').innerHTML = `Time: <b>${this.formatTime(time)}</b> &nbsp;&bull;&nbsp; Rings: <b>${rings}</b>`;
            const nextBtn = document.getElementById('btn-next-level');
            nextBtn.style.display = Game.currentLevelIndex < LevelManager.levels.length - 1 ? 'inline-block' : 'none';
            Game.setState(GAME_STATE.LEVEL_COMPLETE);
        },
        buildLevelSelect() {
            const grid = document.getElementById('level-select-grid');
            grid.innerHTML = '';
            LevelManager.levels.forEach((level, i) => {
                const card = document.createElement('div');
                card.className = 'level-card';
                card.innerHTML = `<h3>${level.name}</h3><div class="best-time">Best: --:--.-</div>`;
                card.addEventListener('click', () => { Game.loadLevel(i); Sfx.play('ui_click'); });
                grid.appendChild(card);
            });
        },
        formatTime(sec) {
            const m = Math.floor(sec / 60);
            const s = Math.floor(sec % 60);
            const ms = Math.floor((sec - Math.floor(sec)) * 10);
            return `${m}:${s.toString().padStart(2,'0')}.${ms}`;
        },
        drawControlIcons() {
            const icons = {
                'arrow-left': (ctx,s) => { ctx.moveTo(s*0.8,s*0.2); ctx.lineTo(s*0.2,s*0.5); ctx.lineTo(s*0.8,s*0.8); },
                'arrow-right':(ctx,s) => { ctx.moveTo(s*0.2,s*0.2); ctx.lineTo(s*0.8,s*0.5); ctx.lineTo(s*0.2,s*0.8); },
                'arrow-down': (ctx,s) => { ctx.moveTo(s*0.2,s*0.2); ctx.lineTo(s*0.5,s*0.8); ctx.lineTo(s*0.8,s*0.2); },
                'jump': (ctx,s) => { ctx.arc(s*0.5,s*0.6,s*0.3,Math.PI,Math.PI*2); ctx.moveTo(s*0.5,s*0.6);ctx.lineTo(s*0.5,s*0.1) },
                'dash': (ctx,s) => { ctx.moveTo(s*0.1,s*0.5); ctx.lineTo(s*0.5,s*0.2); ctx.lineTo(s*0.5,s*0.8); ctx.lineTo(s*0.9,s*0.5); }
            };
            document.querySelectorAll('[data-icon]').forEach(c => {
                const ctx = c.getContext('2d');
                ctx.strokeStyle = '#0b1020'; ctx.lineWidth = c.width * 0.12; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                ctx.beginPath();
                icons[c.dataset.icon](ctx, c.width);
                ctx.stroke();
            });
        }
    };

    const Sprite = class {
        constructor(atlas, defs) {
            this.atlas = atlas;
            this.defs = defs;
            this.currentAnim = null;
            this.frameIndex = 0;
            this.frameTimer = 0;
        }
        setAnim(name) {
            if (this.currentAnim === name) return;
            this.currentAnim = name;
            this.frameIndex = 0;
            this.frameTimer = 0;
        }
        update(dt) {
            if (!this.currentAnim || !this.defs[this.currentAnim]) return;
            const anim = this.defs[this.currentAnim];
            this.frameTimer += dt;
            if (this.frameTimer >= anim.speed) {
                this.frameTimer = 0;
                this.frameIndex++;
                if (this.frameIndex >= anim.frames.length) {
                    this.frameIndex = anim.loop ? 0 : anim.frames.length - 1;
                }
            }
        }
        draw(ctx, x, y, flipX = false) {
            if (!this.currentAnim || !this.atlas || !this.defs[this.currentAnim]) return;
            const anim = this.defs[this.currentAnim];
            const frame = anim.frames[this.frameIndex];
            if (!frame || frame.length < 4) return;
            const w = frame[2], h = frame[3];
            ctx.save();
            ctx.translate(x, y);
            if (flipX) ctx.scale(-1, 1);
            ctx.drawImage(this.atlas, frame[0], frame[1], w, h, -w / 2, -h / 2, w, h);
            ctx.restore();
        }
    };

    const Renderer = {
        canvas: null, ctx: null,
        spriteAtlas: null,
        init() {
            this.canvas = document.getElementById("game-canvas");
            this.ctx = this.canvas.getContext("2d", { alpha: true });
            window.addEventListener("resize", () => this.resize(), { passive: true });
            this.resize();
            this.createSpriteAtlas();
        },
        resize() {
            const dpr = window.devicePixelRatio || 1;
            this.canvas.width = window.innerWidth * dpr;
            this.canvas.height = window.innerHeight * dpr;
            this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            if (Game.camera) {
                Game.camera.resize(this.canvas.clientWidth, this.canvas.clientHeight);
            }
        },
        clear() {
            this.ctx.clearRect(0, 0, this.canvas.clientWidth, this.canvas.clientHeight);
        },
        render(game) {
            this.clear();
            const { player, world, camera, particles } = game;
            
            if (world) this.drawBackground(camera, world.theme);

            this.ctx.save();
            this.ctx.translate(
                -Math.floor(camera.x) + (camera.shake > 0 ? RNG.range(-camera.shake, camera.shake) : 0),
                -Math.floor(camera.y) + (camera.shake > 0 ? RNG.range(-camera.shake, camera.shake) : 0)
            );
            
            if (world) {
                this.drawWorld(world);
                this.drawEntities(world.entities);
            }
            if (player) player.draw(this.ctx);
            this.drawParticles(particles);

            this.ctx.restore();
        },
        drawBackground(camera, theme) {
            if (!theme) return;
            const w = this.canvas.clientWidth;
            const h = this.canvas.clientHeight;
            const sky = this.ctx.createLinearGradient(0, 0, 0, h);
            sky.addColorStop(0, theme.sky1);
            sky.addColorStop(0.6, theme.sky2);
            sky.addColorStop(1, theme.sky3);
            this.ctx.fillStyle = sky;
            this.ctx.fillRect(0, 0, w, h);

            if (theme.name === 'night') {
                this.ctx.save();
                this.ctx.fillStyle = '#fff';
                for (let i = 0; i < 100; i++) {
                    const x = ((i*37.5) % w + camera.x * 0.1) % w;
                    const y = ((i*101.3) % h + camera.y * 0.1) % h;
                    const a = Math.sin((performance.now() + i*100) / (2000 + i*50)) * 0.5 + 0.5;
                    this.ctx.globalAlpha = a;
                    this.ctx.fillRect(x,y, i%3+1, i%3+1);
                }
                this.ctx.restore();
            }

            if (theme.parallax) {
                theme.parallax.forEach(layer => {
                    this.ctx.save();
                    this.ctx.translate(-(camera.x * layer.speed), -camera.y * 0.1);
                    this.ctx.fillStyle = layer.color;
                    this.ctx.globalAlpha = layer.alpha;
                    const world = Game.world;
                    for (let i = -1; i < (world ? world.width : 4000) / layer.w + 2; i++) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(i * layer.w, h);
                        this.ctx.lineTo(i * layer.w, h - layer.h * 0.6);
                        this.ctx.bezierCurveTo(i * layer.w + layer.w * 0.3, h - layer.h, i * layer.w + layer.w * 0.7, h - layer.h, i * layer.w + layer.w, h - layer.h * 0.6);
                        this.ctx.lineTo(i * layer.w + layer.w, h);
                        this.ctx.fill();
                    }
                    this.ctx.restore();
                });
            }
        },
        drawWorld(world) {
            if (!world || !world.platforms) return;
            world.platforms.forEach(p => {
                const grad = this.ctx.createLinearGradient(0, p.y, 0, p.y + p.h);
                grad.addColorStop(0, world.theme.groundTop);
                grad.addColorStop(0.1, world.theme.groundFace);
                grad.addColorStop(1, world.theme.groundBottom);
                this.ctx.fillStyle = grad;
                this.ctx.fillRect(p.x, p.y, p.w, p.h);
                this.ctx.fillStyle = world.theme.grass;
                this.ctx.fillRect(p.x, p.y - 4, p.w, 6);
            });
        },
        drawEntities(entities) {
            if (!entities) return;
            entities.forEach(e => {
                if (e.alive !== false) e.draw(this.ctx);
            });
        },
        drawParticles(particles) {
            if (!particles) return;
            particles.forEach(p => {
                const alpha = 1 - (p.t / p.life);
                this.ctx.save();
                this.ctx.globalAlpha = clamp(alpha, 0, 1);
                this.ctx.fillStyle = p.color;
                this.ctx.translate(p.x, p.y);
                this.ctx.rotate(p.rot);
                this.ctx.scale(p.scale, p.scale);
                this.ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                this.ctx.restore();
            });
        },
        createSpriteAtlas() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Player sprites
            const drawPlayerBody = (x,y, headColor, bodyColor) => {
                ctx.fillStyle = bodyColor; 
                ctx.beginPath(); 
                ctx.ellipse(x+20, y+32, 12, 16, 0,0,Math.PI*2); 
                ctx.fill();
                ctx.fillStyle = headColor; 
                ctx.beginPath(); 
                ctx.ellipse(x+20, y+14, 14, 14, 0,0,Math.PI*2); 
                ctx.fill();
                ctx.fillStyle = '#000'; 
                ctx.beginPath(); 
                ctx.ellipse(x+26, y+14, 3, 4, 0,0,Math.PI*2); 
                ctx.fill();
            };
            
            drawPlayerBody(0,0, '#00bde3', '#00c7ff'); // Idle
            drawPlayerBody(50,0, '#00bde3', '#00c7ff'); // Run1
            drawPlayerBody(100,0, '#00bde3', '#00c7ff'); // Run2
            ctx.fillStyle = '#00c7ff'; ctx.beginPath(); ctx.arc(170, 25, 18, 0, Math.PI*2); ctx.fill(); // Roll
            drawPlayerBody(200,0, '#ccc', '#ddd'); // Hurt
            
            // Enemies
            ctx.fillStyle = '#ffde7d'; ctx.beginPath(); ctx.ellipse(30, 80, 21, 15, 0,0,Math.PI*2); ctx.fill(); // Wasp body
            ctx.fillStyle = '#333'; ctx.beginPath(); ctx.ellipse(45, 78, 5, 5, 0,0,Math.PI*2); ctx.fill(); // Wasp eye
            ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.beginPath(); ctx.ellipse(20, 68, 12, 6, -0.5,0,Math.PI*2); ctx.fill(); // Wasp wing
            
            ctx.fillStyle = '#889'; ctx.fillRect(80, 70, 40, 30); // Patrol bot body
            ctx.fillStyle = '#c33'; ctx.fillRect(95, 75, 10, 10); // Patrol bot eye
            ctx.fillStyle = '#667'; ctx.fillRect(80, 100, 40, 8); // Patrol bot tread

            // Items
            const g = ctx.createRadialGradient(145, 75, 2, 150, 80, 14);
            g.addColorStop(0, "#fff7c2"); g.addColorStop(0.4, "#ffd84d"); g.addColorStop(1, "#b78000"); 
            ctx.fillStyle=g;
            ctx.beginPath();ctx.arc(150,80,14,0,Math.PI*2);ctx.fill(); 
            ctx.clearRect(150-7,80-7,14,14);

            ctx.fillStyle = '#a0a0a0'; ctx.fillRect(180, 76, 14, 80); // Checkpoint
            ctx.fillStyle = '#34ff8a'; ctx.fillRect(200, 76, 14, 80); // Checkpoint Active
            
            ctx.fillStyle = '#3ad3ff'; ctx.fillRect(230, 76, 40, 24); // Spring
            ctx.fillStyle = '#f55'; ctx.beginPath(); ctx.moveTo(280,100); ctx.lineTo(290,76); ctx.lineTo(300,100); ctx.fill(); // Spike
            
            this.spriteAtlas = canvas;
        }
    };
    
    // --- ENTITY CLASSES ---
    class Entity {
        constructor(x,y,w,h) { 
            this.x=x;this.y=y;this.w=w;this.h=h; 
            this.alive=true; 
        }
        update(dt, world) {}
        draw(ctx) {}
        getBBox() { return { x: this.x, y: this.y, w: this.w, h: this.h }; }
    }
    
    class Ring extends Entity {
        constructor(x,y) { 
            super(x-14,y-14,28,28); 
            this.type=ENTITY_TYPE.RING; 
            this.collected=false; 
            this.phase = RNG.range(0,Math.PI*2); 
        }
        draw(ctx) { 
            if(!this.collected && Renderer.spriteAtlas) {
                ctx.drawImage(Renderer.spriteAtlas, 136, 66, 28, 28, this.x, this.y + Math.sin(this.phase)*6, 28, 28);
            }
        }
        update(dt) { this.phase += dt * 3; }
    }
    
    class Checkpoint extends Entity {
        constructor(x,y) { 
            super(x,y,14,80); 
            this.type=ENTITY_TYPE.CHECKPOINT; 
            this.activated=false; 
        }
        draw(ctx) {
            if (Renderer.spriteAtlas) {
                const sx = this.activated ? 200 : 180;
                ctx.drawImage(Renderer.spriteAtlas, sx, 76, 14, 80, this.x, this.y, 14, 80);
            }
        }
    }
    
    class EnemyWasp extends Entity {
        constructor(x,y, range = 160) {
            super(x-21,y-15,42,30); 
            this.type=ENTITY_TYPE.ENEMY_WASP; 
            this.baseX=x; this.range=range; this.speed=120; this.t=0;
        }
        update(dt) { 
            this.t += dt; 
            this.x = this.baseX + Math.sin(this.t * (this.speed/this.range)) * this.range - this.w/2; 
        }
        draw(ctx) { 
            if (Renderer.spriteAtlas) {
                ctx.drawImage(Renderer.spriteAtlas, 14, 62, 42, 36, this.x, this.y, 42, 36); 
            }
        }
    }
    
    class PatrolBot extends Entity {
        constructor(x,y, platform) {
            super(x,y-38,40,38); 
            this.type=ENTITY_TYPE.ENEMY_PATROL;
            this.vx = 80; 
            this.platform = platform; 
        }
        update(dt) {
            if (!this.platform) return;
            this.x += this.vx * dt;
            if (this.x < this.platform.x || this.x + this.w > this.platform.x + this.platform.w) {
                this.vx *= -1;
                this.x = clamp(this.x, this.platform.x, this.platform.x + this.platform.w - this.w);
            }
        }
        draw(ctx) { 
            if (Renderer.spriteAtlas) {
                ctx.drawImage(Renderer.spriteAtlas, 80, 70, 40, 38, this.x, this.y, 40, 38); 
            }
        }
    }
    
    class Spring extends Entity {
        constructor(x,y) { 
            super(x,y,40,24); 
            this.type=ENTITY_TYPE.SPRING; 
            this.power=1400; 
        }
        draw(ctx) { 
            if (Renderer.spriteAtlas) {
                ctx.drawImage(Renderer.spriteAtlas, 230, 76, 40, 24, this.x, this.y, 40, 24); 
            }
        }
    }
    
    class Spike extends Entity {
        constructor(x,y,w=40) { 
            super(x,y,w,24); 
            this.type=ENTITY_TYPE.SPIKE; 
        }
        draw(ctx) {
            if (Renderer.spriteAtlas) {
                for(let i=0; i<this.w/20; i++) {
                    ctx.drawImage(Renderer.spriteAtlas, 280, 76, 20, 24, this.x+i*20, this.y, 20, 24);
                }
            }
        }
    }
    
    class Goal extends Entity {
        constructor(x,y) { 
            super(x,y,64,64); 
            this.type = ENTITY_TYPE.GOAL; 
        }
        draw(ctx) {
            ctx.fillStyle = '#333'; 
            ctx.fillRect(this.x-6+32, this.y-16, 12, this.h+16);
            for(let yy=0;yy<4;yy++) {
                for(let xx=0;xx<4;xx++) {
                    ctx.fillStyle = (xx+yy)%2 ? '#fff' : '#000';
                    ctx.fillRect(this.x + xx*16, this.y + yy*16, 16, 16);
                }
            }
        }
    }
    
    // --- PLAYER CLASS ---
    const PLAYER_STATE = { IDLE: 0, RUN: 1, JUMP: 2, FALL: 3, ROLL: 4, WALL_SLIDE: 5, HURT: 6, DEAD: 7 };
    
    class Player extends Entity {
        constructor(x, y) {
            super(x, y, 36, 48);
            this.state = PLAYER_STATE.FALL;
            this.vx = 0; this.vy = 0;
            this.onGround = false;
            this.facing = 1;
            this.dashCD = 0;
            this.invTime = 0;
            this.ringCount = 0;
            this.spawn = { x, y };
            this.coyoteTimer = 0;
            this.jumpBufferTimer = 0;
            this.wallDir = 0;
            this.sprite = null;
            this.initSprite();
        }

        initSprite() {
            this.sprite = new Sprite(Renderer.spriteAtlas, {
                idle: { frames: [[0,0,40,50]], speed: 1, loop: true },
                run:  { frames: [[50,0,40,50],[100,0,40,50]], speed: 0.1, loop: true },
                jump: { frames: [[50,0,40,50]], speed: 1, loop: false },
                fall: { frames: [[100,0,40,50]], speed: 1, loop: false },
                roll: { frames: [[160,10,40,40]], speed: 1, loop: true },
                wall_slide: { frames: [[0,0,40,50]], speed: 1, loop: false },
                hurt: { frames: [[200,0,40,50]], speed: 1, loop: false },
            });
        }

        update(dt, world) {
            if (!this.sprite) this.initSprite();
            
            // Timers
            if(this.dashCD > 0) this.dashCD -= dt;
            if(this.invTime > 0) this.invTime -= dt;
            if(this.coyoteTimer > 0) this.coyoteTimer -= dt;
            if(this.jumpBufferTimer > 0) this.jumpBufferTimer -= dt;

            const prevState = this.state;
            if (this.state === PLAYER_STATE.DEAD) {
                return;
            }
            if (this.state === PLAYER_STATE.HURT) {
                if(this.invTime <= 0) this.setState(PLAYER_STATE.FALL);
            }

            // Gravity
            if (!this.onGround) this.vy += CFG.GRAVITY * dt;

            // Input Buffering
            if (Input.isPressed('up') || Input.isPressed(' ')) this.jumpBufferTimer = CFG.JUMP_BUFFER_TIME;
            
            this.handleState(dt, world);

            // Physics
            this.x += this.vx * dt; 
            this.y += this.vy * dt;
            this.onGround = false; 
            this.wallDir = 0;

            this.resolveCollisions(world);

            if (this.onGround && prevState !== PLAYER_STATE.JUMP) this.coyoteTimer = CFG.COYOTE_TIME;

            // World bounds check
            if (world && this.y > world.height + 500) this.die();

            // Update sprite
            if (this.sprite) this.sprite.update(dt);
        }

        handleState(dt, world) {
            const onG = this.onGround;
            // State transitions
            switch (this.state) {
                case PLAYER_STATE.IDLE:
                case PLAYER_STATE.RUN:
                    if (!onG) this.setState(PLAYER_STATE.FALL);
                    else if (this.jumpBufferTimer > 0 || (this.coyoteTimer > 0 && (Input.up || Input.isPressed('up')))) this.jump();
                    else if (Input.down && Math.abs(this.vx) > CFG.ROLL_SPEED_MIN) this.setState(PLAYER_STATE.ROLL);
                    else if (Input.left || Input.right) this.setState(PLAYER_STATE.RUN);
                    else this.setState(PLAYER_STATE.IDLE);
                    break;
                case PLAYER_STATE.JUMP:
                case PLAYER_STATE.FALL:
                    if (onG) this.land();
                    else if (this.jumpBufferTimer > 0 && (this.coyoteTimer > 0 || this.wallDir !== 0)) {
                        if (this.wallDir !== 0) this.wallJump();
                        else this.jump();
                    }
                    else if (this.wallDir !== 0 && !onG) this.setState(PLAYER_STATE.WALL_SLIDE);
                    else if (this.vy > 0) this.setState(PLAYER_STATE.FALL);
                    break;
                case PLAYER_STATE.ROLL:
                    if (!onG) this.setState(PLAYER_STATE.FALL);
                    else if (!Input.down || Math.abs(this.vx) < CFG.ROLL_SPEED_MIN * 0.8) this.setState(PLAYER_STATE.RUN);
                    else if (this.jumpBufferTimer > 0) this.jump();
                    break;
                case PLAYER_STATE.WALL_SLIDE:
                    if (onG) this.land();
                    else if (this.jumpBufferTimer > 0) this.wallJump();
                    else if (this.wallDir === 0 || (Input.right && this.wallDir === -1) || (Input.left && this.wallDir === 1)) this.setState(PLAYER_STATE.FALL);
                    break;
            }

            // Movement
            let ax = 0;
            const maxSpeed = this.dashCD > CFG.DASH_COOLDOWN - 0.2 ? CFG.MAX_DASH_SPEED : (onG ? CFG.MAX_SPEED : CFG.MAX_AIR_SPEED);
            
            if (Input.left) { 
                ax -= onG ? CFG.ACCEL_GROUND : CFG.ACCEL_AIR; 
                if(onG || this.state !== PLAYER_STATE.WALL_SLIDE) this.facing = -1; 
            }
            if (Input.right) { 
                ax += onG ? CFG.ACCEL_GROUND : CFG.ACCEL_AIR; 
                if(onG || this.state !== PLAYER_STATE.WALL_SLIDE) this.facing = 1; 
            }

            if (onG && ax === 0) {
                const decel = this.state === PLAYER_STATE.ROLL ? CFG.DECEL_ROLL : CFG.DECEL_GROUND;
                this.vx = lerp(this.vx, 0, decel / 10000);
            } else {
                this.vx += ax * dt;
                this.vx = clamp(this.vx, -maxSpeed, maxSpeed);
            }
            
            if (this.state === PLAYER_STATE.WALL_SLIDE) {
                this.vy = clamp(this.vy, -Infinity, CFG.WALL_SLIDE_SPEED);
            }
            
            // Variable jump height
            if (!Input.up && this.vy < 0) this.vy = 0;
            
            // Dash
            if ((Input.isPressed('dash') || Input.isPressed('x')) && this.dashCD <= 0) this.dash();
        }

        setState(newState) {
            if (this.state === newState) return;
            this.state = newState;
            if (!this.sprite) this.initSprite();
            
            switch(newState) {
                case PLAYER_STATE.IDLE: this.sprite.setAnim('idle'); this.h=48; break;
                case PLAYER_STATE.RUN: this.sprite.setAnim('run'); this.h=48; break;
                case PLAYER_STATE.JUMP: this.sprite.setAnim('jump'); this.h=48; break;
                case PLAYER_STATE.FALL: this.sprite.setAnim('fall'); this.h=48; break;
                case PLAYER_STATE.ROLL: Sfx.play('land',1.2,0.2); this.sprite.setAnim('roll'); this.h=40; break;
                case PLAYER_STATE.WALL_SLIDE: this.sprite.setAnim('wall_slide'); this.h=48; break;
                case PLAYER_STATE.HURT: this.sprite.setAnim('hurt'); break;
            }
        }
        
        jump() {
            this.vy = -CFG.JUMP_VELOCITY;
            this.coyoteTimer = 0;
            this.jumpBufferTimer = 0;
            this.setState(PLAYER_STATE.JUMP);
            Sfx.play('jump');
            Game.addParticles(this.x, this.y+this.h/2, 5, { color: 'rgba(255,255,255,0.5)', life: 0.3, vy: -150 });
        }
        
        land() {
            this.setState(PLAYER_STATE.IDLE);
            Sfx.play('land', 1, 0.4);
            Game.addParticles(this.x, this.y+this.h/2, 3, { color: 'rgba(255,255,255,0.5)', life: 0.2 });
        }

        wallJump() {
            this.vy = -CFG.WALL_JUMP_VELOCITY.y;
            this.vx = this.wallDir * -CFG.WALL_JUMP_VELOCITY.x;
            this.facing = -this.wallDir;
            this.jumpBufferTimer = 0;
            this.setState(PLAYER_STATE.JUMP);
            Sfx.play('jump', 1.2);
            Game.addParticles(this.x-this.wallDir*this.w/2, this.y, 8, { color: '#fff', life: 0.4, vx: -this.wallDir*150 });
        }
        
        dash() {
            this.vx += this.facing * CFG.DASH_BOOST;
            this.dashCD = CFG.DASH_COOLDOWN;
            Game.camera.shake = 8;
            Sfx.play('dash');
            Game.addParticles(this.x, this.y, 12, { color: 'rgba(0, 220, 255, 0.8)', life: 0.3, vx: this.facing * 300 });
        }

        resolveCollisions(world) {
            if (!world || !world.platforms) return;
            // Platform collision
            for (const p of world.platforms) {
                if (this.x + this.w > p.x && this.x < p.x + p.w && this.y + this.h > p.y && this.y < p.y + p.h) {
                    const overlapX = (this.vx > 0) ? (this.x + this.w) - p.x : (p.x + p.w) - this.x;
                    const overlapY = (this.vy > 0) ? (this.y + this.h) - p.y : (p.y + p.h) - this.y;

                    if (p.path) { // Moving platform
                        this.x += (p.vx || 0) * (world.dt || 1/60);
                    }

                    if (overlapY < overlapX) {
                        if (this.vy > 0) { // Land on top
                            this.y = p.y - this.h;
                            this.vy = p.path ? (p.vy || 0) : 0;
                            this.onGround = true;
                        } else { // Hit from bottom
                            this.y = p.y + p.h;
                            this.vy = 0;
                        }
                    } else { // Wall collision
                        if (this.vx > 0) { 
                            this.x = p.x - this.w; 
                            this.wallDir = 1; 
                        } else { 
                            this.x = p.x + p.w; 
                            this.wallDir = -1; 
                        }
                        this.vx = 0;
                    }
                }
            }
        }

        takeHit() {
            if (this.invTime > 0) return;
            Game.camera.shake = 12;
            Sfx.play('hurt');
            if (this.ringCount > 0) {
                this.ringCount = 0;
                Game.addParticles(this.x, this.y, 20, { color: '#ffd84d', size: 8, life: 1.0, vy: -400 });
                this.invTime = CFG.INVINCIBLE_TIME;
                this.setState(PLAYER_STATE.HURT);
                this.vy = -400;
            } else {
                this.die();
            }
        }
        
        die() {
            if (this.state === PLAYER_STATE.DEAD) return;
            this.setState(PLAYER_STATE.DEAD);
            this.vx = 0; this.vy = 0;
            Game.camera.shake = 16;
            Sfx.play('hurt', 0.8);
            Game.addParticles(this.x, this.y, 30, { color: '#00c7ff', life: 0.8, size: 6 });
            setTimeout(() => this.respawn(), CFG.RESPAWN_TIME * 1000);
        }

        respawn() {
            this.x = this.spawn.x;
            this.y = this.spawn.y;
            this.vx = 0; this.vy = 0;
            this.ringCount = Math.floor(this.ringCount / 2);
            this.invTime = CFG.INVINCIBLE_TIME;
            this.setState(PLAYER_STATE.FALL);
            Sfx.play('ui_click', 0.8);
        }

        draw(ctx) {
            if (this.state === PLAYER_STATE.DEAD) return;
            const isHurt = this.invTime > 0 && Math.floor(performance.now() / 100) % 2 === 0;
            if (isHurt) { ctx.globalAlpha = 0.5; }
            if (this.sprite) {
                this.sprite.draw(ctx, this.x + this.w / 2, this.y + this.h / 2, this.facing === -1);
            }
            ctx.globalAlpha = 1;
        }
    }

    const Camera = {
        x: 0, y: 0, shake: 0, w: 800, h: 600,
        update(dt, player, world) {
            if (!player || !world) return;
            const targetX = player.x + player.w/2 - this.w/2 + player.facing * clamp(Math.abs(player.vx), 0, 200);
            const targetY = player.y + player.h/2 - this.h/2.2;
            this.x = lerp(this.x, clamp(targetX, 0, world.width - this.w), 0.1);
            this.y = lerp(this.y, clamp(targetY, 0, world.height - this.h), 0.1);
            if (this.shake > 0) this.shake -= 60 * dt;
        },
        resize(w,h) { this.w = w; this.h = h; }
    };
    
    // --- LEVEL DEFINITIONS ---
    const LevelManager = {
        levels: [
            {
                name: "Momentum Valley",
                startX: 150, startY: 400,
                width: 4000, height: 1200,
                theme: {
                    name: 'day',
                    sky1: '#6ec6ff', sky2: '#b9f0ff', sky3: '#e9fff5',
                    groundTop: '#5fb54b', groundFace: '#7b5a29', groundBottom: '#543f1a', grass: '#9be168',
                    parallax: [
                        {speed:0.2,color:'#cfefff',h:140,w:500, alpha:0.8},
                        {speed:0.4,color:'#ff8c69',h:250,w:800, alpha:0.8}
                    ]
                },
                music: [58, 62, 65, 58, 70, 65, 62, 58], tempo: 130,
                entities: [
                    // A nice starting ramp
                    { type: ENTITY_TYPE.PLATFORM, x: 0, y: 800, w: 500, h: 400 },
                    { type: ENTITY_TYPE.PLATFORM, x: 500, y: 750, w: 200, h: 450 },
                    { type: ENTITY_TYPE.PLATFORM, x: 700, y: 700, w: 200, h: 500 },

                    // A series of smaller platforms to jump across
                    { type: ENTITY_TYPE.PLATFORM, x: 1000, y: 650, w: 150, h: 550 },
                    { type: ENTITY_TYPE.PLATFORM, x: 1250, y: 600, w: 150, h: 600 },
                    { type: ENTITY_TYPE.PLATFORM, x: 1500, y: 550, w: 150, h: 650 },

                    // A wall to wall-jump off
                    { type: ENTITY_TYPE.PLATFORM, x: 1800, y: 500, w: 50, h: 400 },

                    // A spring to a high platform
                    { type: ENTITY_TYPE.PLATFORM, x: 2000, y: 800, w: 200, h: 400 },
                    { type: ENTITY_TYPE.SPRING, x: 2050, y: 776 },
                    { type: ENTITY_TYPE.PLATFORM, x: 2000, y: 400, w: 200, h: 400 },

                    // A long platform with a wasp
                    { type: ENTITY_TYPE.PLATFORM, x: 2400, y: 700, w: 600, h: 500 },
                    { type: ENTITY_TYPE.ENEMY_WASP, x: 2700, y: 550 },

                    // Checkpoint
                    { type: ENTITY_TYPE.CHECKPOINT, x: 3100, y: 620 },

                    // A tricky jump with a spike pit
                    { type: ENTITY_TYPE.PLATFORM, x: 3200, y: 700, w: 100, h: 500 },
                    { type: ENTITY_TYPE.SPIKE, x: 3300, y: 1176, w: 200 },
                    { type: ENTITY_TYPE.PLATFORM, x: 3500, y: 700, w: 100, h: 500 },

                    // Final platform with goal
                    { type: ENTITY_TYPE.PLATFORM, x: 3800, y: 600, w: 200, h: 600 },
                    { type: ENTITY_TYPE.GOAL, x: 3900, y: 536 },

                    // Rings to guide the player
                    { type: ENTITY_TYPE.RING, x: 600, y: 650 },
                    { type: ENTITY_TYPE.RING, x: 800, y: 600 },
                    { type: ENTITY_TYPE.RING, x: 1100, y: 550 },
                    { type: ENTITY_TYPE.RING, x: 1350, y: 500 },
                    { type: ENTITY_TYPE.RING, x: 1600, y: 450 },
                    { type: ENTITY_TYPE.RING, x: 2100, y: 350 },
                    { type: ENTITY_TYPE.RING, x: 2600, y: 600 },
                    { type: ENTITY_TYPE.RING, x: 2800, y: 600 },
                    { type: ENTITY_TYPE.RING, x: 3000, y: 600 },
                    { type: ENTITY_TYPE.RING, x: 3250, y: 600 },
                    { type: ENTITY_TYPE.RING, x: 3550, y: 600 },
                ]
            },
            {
                name: "Emerald Hillside",
                startX: 150, startY: 400,
                width: 4000, height: 1200,
                theme: { 
                    name: 'day', 
                    sky1: '#6ec6ff', sky2: '#b9f0ff', sky3: '#e9fff5', 
                    groundTop: '#5fb54b', groundFace: '#7b5a29', groundBottom: '#543f1a', grass: '#9be168', 
                    parallax: [
                        {speed:0.2,color:'#cfefff',h:140,w:500, alpha:0.8},
                        {speed:0.4,color:'#ff8c69',h:250,w:800, alpha:0.8}
                    ] 
                },
                music: [58, 62, 65, 58, 70, 65, 62, 58], tempo: 130,
                entities: [
                    { type: ENTITY_TYPE.PLATFORM, x: 0, y: 800, w: 400, h: 400 },
                    { type: ENTITY_TYPE.PLATFORM, x: 600, y: 900, w: 300, h: 300 },
                    { type: ENTITY_TYPE.PLATFORM, x: 1100, y: 750, w: 200, h: 450 },
                    { type: ENTITY_TYPE.PLATFORM, x: 1500, y: 650, w: 400, h: 550 },
                    { type: ENTITY_TYPE.PLATFORM, x: 2100, y: 800, w: 250, h: 400 },
                    { type: ENTITY_TYPE.PLATFORM, x: 2600, y: 700, w: 300, h: 650 },
                    { type: ENTITY_TYPE.PLATFORM, x: 3200, y: 750, w: 600, h: 450 },

                    { type: ENTITY_TYPE.RING, x: 250, y: 750 },
                    { type: ENTITY_TYPE.RING, x: 750, y: 850 },
                    { type: ENTITY_TYPE.RING, x: 1200, y: 700 },
                    { type: ENTITY_TYPE.RING, x: 1700, y: 600 },
                    { type: ENTITY_TYPE.RING, x: 2200, y: 750 },
                    { type: ENTITY_TYPE.RING, x: 2750, y: 500 },

                    { type: ENTITY_TYPE.SPRING, x: 460, y: 876 },
                    { type: ENTITY_TYPE.SPRING, x: 2570, y: 526 },

                    { type: ENTITY_TYPE.SPIKE, x: 1000, y: 1176, w: 100 },
                    { type: ENTITY_TYPE.SPIKE, x: 1400, y: 1176, w: 100 },

                    { type: ENTITY_TYPE.ENEMY_WASP, x: 1200, y: 600 },
                    { type: ENTITY_TYPE.ENEMY_WASP, x: 2400, y: 400 },

                    { type: ENTITY_TYPE.CHECKPOINT, x: 1600, y: 570 },
                    { type: ENTITY_TYPE.CHECKPOINT, x: 2700, y: 470 },

                    { type: ENTITY_TYPE.GOAL, x: 3500, y: 686 }
                ]
            },
            {
                name: "Neon Canyon",
                startX: 100, startY: 300,
                width: 3500, height: 1000,
                theme: { 
                    name: 'night', 
                    sky1: '#1a1a2e', sky2: '#16213e', sky3: '#0f3460', 
                    groundTop: '#444', groundFace: '#222', groundBottom: '#111', grass: '#333',
                    parallax: [
                        {speed:0.15,color:'#ff006e',h:100,w:400, alpha:0.6},
                        {speed:0.3,color:'#8338ec',h:180,w:600, alpha:0.7}
                    ] 
                },
                entities: [
                    { type: ENTITY_TYPE.PLATFORM, x: 0, y: 700, w: 300, h: 300 },
                    { type: ENTITY_TYPE.PLATFORM, x: 500, y: 600, w: 200, h: 400 },
                    { type: ENTITY_TYPE.PLATFORM, x: 900, y: 500, w: 150, h: 500 },
                    { type: ENTITY_TYPE.PLATFORM, x: 1300, y: 450, w: 250, h: 600 },
                    { type: ENTITY_TYPE.PLATFORM, x: 1800, y: 600, w: 200, h: 400 },
                    { type: ENTITY_TYPE.PLATFORM, x: 2200, y: 750, w: 300, h: 250 },
                    { type: ENTITY_TYPE.PLATFORM, x: 2800, y: 500, w: 400, h: 500 },

                    { type: ENTITY_TYPE.RING, x: 150, y: 650 },
                    { type: ENTITY_TYPE.RING, x: 600, y: 550 },
                    { type: ENTITY_TYPE.RING, x: 975, y: 450 },
                    { type: ENTITY_TYPE.RING, x: 1425, y: 350 },
                    { type: ENTITY_TYPE.RING, x: 1900, y: 550 },
                    { type: ENTITY_TYPE.RING, x: 2350, y: 700 },
                    { type: ENTITY_TYPE.RING, x: 3000, y: 450 },

                    { type: ENTITY_TYPE.SPRING, x: 270, y: 676 },
                    { type: ENTITY_TYPE.SPRING, x: 1570, y: 376 },

                    { type: ENTITY_TYPE.SPIKE, x: 800, y: 976, w: 100 },
                    { type: ENTITY_TYPE.SPIKE, x: 2100, y: 976, w: 100 },

                    { type: ENTITY_TYPE.ENEMY_WASP, x: 1100, y: 250 },
                    { type: ENTITY_TYPE.ENEMY_WASP, x: 2500, y: 350, range: 240 },

                    { type: ENTITY_TYPE.CHECKPOINT, x: 1000, y: 420 },
                    { type: ENTITY_TYPE.CHECKPOINT, x: 2300, y: 670 },

                    { type: ENTITY_TYPE.GOAL, x: 3100, y: 436 }
                ]
            },
            {
                name: "Sky Temple",
                startX: 100, startY: 200,
                width: 4500, height: 1400,
                theme: { 
                    name: 'sky', 
                    sky1: '#87ceeb', sky2: '#b0e0e6', sky3: '#f0f8ff', 
                    groundTop: '#d4af37', groundFace: '#b8860b', groundBottom: '#8b7355', grass: '#ffd700',
                    parallax: [
                        {speed:0.1,color:'rgba(255,255,255,0.3)',h:120,w:600, alpha:0.9},
                        {speed:0.25,color:'rgba(255,215,0,0.2)',h:200,w:900, alpha:0.8}
                    ] 
                },
                entities: [
                    { type: ENTITY_TYPE.PLATFORM, x: 0, y: 600, w: 250, h: 800 },
                    { type: ENTITY_TYPE.PLATFORM, x: 400, y: 500, w: 200, h: 900 },
                    { type: ENTITY_TYPE.PLATFORM, x: 800, y: 400, w: 150, h: 1050 },
                    { type: ENTITY_TYPE.PLATFORM, x: 1200, y: 250, w: 300, h: 1150 },
                    { type: ENTITY_TYPE.PLATFORM, x: 1700, y: 400, w: 200, h: 1000 },
                    { type: ENTITY_TYPE.PLATFORM, x: 2100, y: 300, w: 250, h: 1100 },
                    { type: ENTITY_TYPE.PLATFORM, x: 2600, y: 450, w: 200, h: 950 },
                    { type: ENTITY_TYPE.PLATFORM, x: 3000, y: 200, w: 300, h: 1200 },
                    { type: ENTITY_TYPE.PLATFORM, x: 3600, y: 350, w: 400, h: 1050 },

                    { type: ENTITY_TYPE.RING, x: 125, y: 550 },
                    { type: ENTITY_TYPE.RING, x: 500, y: 450 },
                    { type: ENTITY_TYPE.RING, x: 875, y: 300 },
                    { type: ENTITY_TYPE.RING, x: 1350, y: 200 },
                    { type: ENTITY_TYPE.RING, x: 1800, y: 350 },
                    { type: ENTITY_TYPE.RING, x: 2225, y: 250 },
                    { type: ENTITY_TYPE.RING, x: 2700, y: 400 },
                    { type: ENTITY_TYPE.RING, x: 3150, y: 150 },
                    { type: ENTITY_TYPE.RING, x: 3800, y: 300 },

                    { type: ENTITY_TYPE.SPRING, x: 220, y: 576 },
                    { type: ENTITY_TYPE.SPRING, x: 1520, y: 226 },
                    { type: ENTITY_TYPE.SPRING, x: 3570, y: 176 },

                    { type: ENTITY_TYPE.ENEMY_WASP, x: 600, y: 200 },
                    { type: ENTITY_TYPE.ENEMY_WASP, x: 1500, y: 100 },
                    { type: ENTITY_TYPE.ENEMY_WASP, x: 2800, y: 100 },
                    { type: ENTITY_TYPE.ENEMY_WASP, x: 4000, y: 200 },

                    { type: ENTITY_TYPE.CHECKPOINT, x: 1350, y: 170 },
                    { type: ENTITY_TYPE.CHECKPOINT, x: 2700, y: 370 },

                    { type: ENTITY_TYPE.GOAL, x: 4000, y: 286 }
                ]
            }
        ],
        
        createEntity(def) {
            switch(def.type) {
                case ENTITY_TYPE.RING: return new Ring(def.x, def.y);
                case ENTITY_TYPE.CHECKPOINT: return new Checkpoint(def.x, def.y);
                case ENTITY_TYPE.ENEMY_WASP: return new EnemyWasp(def.x, def.y, def.range);
                case ENTITY_TYPE.ENEMY_PATROL: return new PatrolBot(def.x, def.y, def.platform);
                case ENTITY_TYPE.SPRING: return new Spring(def.x, def.y);
                case ENTITY_TYPE.SPIKE: return new Spike(def.x, def.y, def.w);
                case ENTITY_TYPE.GOAL: return new Goal(def.x, def.y);
                default: return null;
            }
        }
    };

    // --- MAIN GAME OBJECT ---
    const Game = {
        state: GAME_STATE.TITLE,
        player: null,
        world: null,
        camera: Camera,
        particles: [],
        currentLevelIndex: 0,
        levelStartTime: 0,
        totalRings: 0,

        init() {
            Sfx.init();
            Input.init();
            Renderer.init();
            UI.init();
            this.startGameLoop();
        },

        setState(newState) {
            this.state = newState;
            UI.update(newState);
            Input.clearPressed();
        },

        togglePause() {
            if (this.state === GAME_STATE.PLAYING) {
                this.setState(GAME_STATE.PAUSED);
            } else if (this.state === GAME_STATE.PAUSED) {
                this.setState(GAME_STATE.PLAYING);
            }
        },

        loadLevel(index) {
            if (index < 0 || index >= LevelManager.levels.length) return;
            this.currentLevelIndex = index;
            const levelDef = LevelManager.levels[index];
            
            // Create world
            this.world = {
                width: levelDef.width,
                height: levelDef.height,
                theme: levelDef.theme,
                platforms: [],
                entities: [],
                dt: 1/60
            };

            // Create platforms
            levelDef.entities.forEach(def => {
                if (def.type === ENTITY_TYPE.PLATFORM) {
                    this.world.platforms.push(def);
                } else {
                    const entity = LevelManager.createEntity(def);
                    if (entity) this.world.entities.push(entity);
                }
            });

            // Create player
            this.player = new Player(levelDef.startX, levelDef.startY);
            
            // Reset game state
            this.levelStartTime = performance.now();
            this.particles = [];
            this.totalRings = this.world.entities.filter(e => e.type === ENTITY_TYPE.RING).length;
            
            this.setState(GAME_STATE.PLAYING);
        },

        addParticles(x, y, count, params = {}) {
            for (let i = 0; i < count; i++) {
                this.particles.push({
                    x: x + RNG.range(-10, 10),
                    y: y + RNG.range(-10, 10),
                    vx: (params.vx || 0) + RNG.range(-100, 100),
                    vy: (params.vy || 0) + RNG.range(-100, 100),
                    size: params.size || RNG.range(2, 6),
                    color: params.color || '#fff',
                    life: params.life || 0.5,
                    t: 0,
                    rot: RNG.range(0, Math.PI * 2),
                    scale: 1
                });
            }
        },

        update(dt) {
            if (this.state !== GAME_STATE.PLAYING) return;

            // Update player
            if (this.player) {
                this.player.update(dt, this.world);
                this.checkEntityCollisions();
            }

            // Update world entities
            if (this.world && this.world.entities) {
                this.world.entities.forEach(e => e.update(dt, this.world));
            }

            // Update camera
            this.camera.update(dt, this.player, this.world);

            // Update particles
            this.particles = this.particles.filter(p => {
                p.t += dt;
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.vy += 500 * dt; // gravity
                p.rot += dt * 5;
                p.scale = 1 - (p.t / p.life) * 0.5;
                return p.t < p.life;
            });

            // Update UI
            const currentTime = (performance.now() - this.levelStartTime) / 1000;
            UI.updateHUD(this.player, currentTime);
        },

        checkEntityCollisions() {
            if (!this.player || !this.world || !this.world.entities) return;
            
            this.world.entities.forEach(e => {
                if (!e.alive || e.collected) return;
                
                // Simple AABB collision
                if (this.player.x < e.x + e.w && this.player.x + this.player.w > e.x &&
                    this.player.y < e.y + e.h && this.player.y + this.player.h > e.y) {
                    
                    switch(e.type) {
                        case ENTITY_TYPE.RING:
                            if (!e.collected) {
                                e.collected = true;
                                this.player.ringCount++;
                                Sfx.play('ring');
                                this.addParticles(e.x + e.w/2, e.y + e.h/2, 8, { 
                                    color: '#ffd84d', life: 0.5, size: 4 
                                });
                            }
                            break;
                        case ENTITY_TYPE.CHECKPOINT:
                            if (!e.activated) {
                                e.activated = true;
                                this.player.spawn.x = e.x;
                                this.player.spawn.y = e.y - this.player.h;
                                Sfx.play('checkpoint');
                                this.addParticles(e.x + e.w/2, e.y + e.h/2, 12, { 
                                    color: '#34ff8a', life: 0.8 
                                });
                            }
                            break;
                        case ENTITY_TYPE.SPRING:
                            this.player.vy = -e.power;
                            this.player.setState(PLAYER_STATE.JUMP);
                            Sfx.play('spring');
                            this.addParticles(e.x + e.w/2, e.y, 15, { 
                                color: '#3ad3ff', life: 0.6, vy: -200 
                            });
                            break;
                        case ENTITY_TYPE.SPIKE:
                            this.player.takeHit();
                            break;
                        case ENTITY_TYPE.ENEMY_WASP:
                        case ENTITY_TYPE.ENEMY_PATROL:
                            this.player.takeHit();
                            break;
                        case ENTITY_TYPE.GOAL:
                            const completionTime = (performance.now() - this.levelStartTime) / 1000;
                            Sfx.play('goal');
                            UI.showLevelComplete(completionTime, this.player.ringCount);
                            this.addParticles(e.x + e.w/2, e.y + e.h/2, 30, { 
                                color: '#fff', life: 1.2, size: 8 
                            });
                            break;
                    }
                }
            });
        },

        render() {
            Renderer.render(this);
        },

        startGameLoop() {
            let lastTime = 0;
            const gameLoop = (timestamp) => {
                const dt = Math.min((timestamp - lastTime) / 1000, 1/30); // Cap at 30fps
                lastTime = timestamp;
                
                this.update(dt);
                this.render();
                
                requestAnimationFrame(gameLoop);
            };
            requestAnimationFrame(gameLoop);
        }
    };

    // Initialize the game when page loads
    window.addEventListener('load', () => Game.init());
  </script>
</body>
</html>
